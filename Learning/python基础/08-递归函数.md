

### 简介

​	一个递归函数的调用过程类似于多个函数的嵌套的调用，只不过调用函数和被调用函数是同一个函数。为了保证递归函数的正确执行，系统需设立一个工作栈。具体地说，递归调用的内部执行过程如下：

-   运动开始时，首先为递归调用建立一个工作栈，其结构包括值参、局部变量和返回地址；
-   每次执行递归调用之前，把递归函数的值参和局部变量的当前值以及调用后的返回地址压栈；
-   每次递归调用结束后，将栈顶元素出栈，使相应的值参和局部变量恢复为调用前的值，然后转向返回地址指定的位置继续执行。  



简单来说:

-   递归就是对函数自身的调用, 但是必须有一个明确的结束条件, 称为递归出口



简单的递归函数

```python

def foo(n):
    
    if n == 1:  # 最后写中间的条件部分
        return 1
    
    return n * foo( n - 1 )  # 优先写递归调用的函数
```

```python
===> fact(5)
===> 5 * fact(4)
===> 5 * (4 * fact(3))
===> 5 * (4 * (3 * fact(2)))
===> 5 * (4 * (3 * (2 * fact(1))))
===> 5 * (4 * (3 * (2 * 1)))
===> 5 * (4 * (3 * 2))
===> 5 * (4 * 6)
===> 5 * 24
===> 120
```

代码来源, [廖雪峰的官方博客](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00137473836826348026db722d9435483fa38c137b7e685000)

>   一般在写递归是, 先将其外层的递归调用写出来, 然后在写中间判断使递归终止的条件, 条件一定要明确, 不然递归会一直递归下去, 造成死循环



#####小结

递归会将前面的调用的函数暂时挂起, 等待递归的终止条件给出的明确的条件, 然后将所有的挂起的内容进行反向计算, 其实, 递归也可以看做是一种反向计算的过程, 前面调用递归的过程只是将表达式罗列出来, 等待终止条件出现后, 依次从后往前倒序进行计算前面挂起的内容, 最后将所有结果一起返回



递归调用的次数过多会导致栈的溢出, 入上例中 `fact(1000)`, 这时就需要优化

尾递归优化

```python

def fact_iter(num, product):
    if num == 1:
        return product
    
    return fact_iter(num - 1, num * product)

def fact(n):
    return fact_iter(n, 1)
```



>   将每次的乘积存入到 product 中,  return fact_iter(num -1, num * product) 返回的仅仅是函数本身, num - 1, 和 num * product 在函数调用前就会被计算出来



上例中的优化其实就是讲 原本的倒序的计算, 通过  num * product 变为了正序的计算, 还是递归的思想, 但是不会占用其他的栈帧, 因为所有的结果都已近存放在了 product 中





递归主要还是有防止溢出, Python标准的解释器并没有对尾递归做出优化, 所有一定要防止 栈溢出  的情况





